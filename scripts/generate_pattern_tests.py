#!/usr/bin/env python3
"""
Pattern Test Generator

Generates pytest test files from pattern YAML files.
Reads test_cases from each pattern and generates comprehensive tests.

Usage:
    python scripts/generate_pattern_tests.py
    python scripts/generate_pattern_tests.py --output tests/generated/
    python scripts/generate_pattern_tests.py --dry-run
"""

import argparse
import re
import sys
from datetime import datetime
from pathlib import Path
from typing import Any

# Try to import PyYAML
try:
    import yaml
except ImportError:
    print("Error: PyYAML is required. Install with: pip install pyyaml")
    sys.exit(1)


# Pattern file locations
PATTERN_FILES = {
    "bash": "primitives/v1/hooks/validators/security/patterns/bash.patterns.yaml",
    "file": "primitives/v1/hooks/validators/security/patterns/file.patterns.yaml",
    "pii": "primitives/v1/hooks/validators/prompt/patterns/pii.patterns.yaml",
}

# Test file template
TEST_FILE_HEADER = '''"""
Generated tests for {pattern_name} patterns.

Auto-generated by scripts/generate_pattern_tests.py
Generated at: {timestamp}

DO NOT EDIT MANUALLY - Changes will be overwritten.
To update tests, modify the test_cases in the pattern YAML files.
"""

import pytest
import re
'''

BASH_TEST_IMPORTS = '''
# Import the validator
import sys
from pathlib import Path

# Add validators to path - find primitives relative to this test file
_test_dir = Path(__file__).parent
_repo_root = _test_dir
while _repo_root.name != "agentic-primitives" and _repo_root != _repo_root.parent:
    _repo_root = _repo_root.parent
_validators_path = _repo_root / "primitives" / "v1" / "hooks" / "validators"
if _validators_path.exists():
    sys.path.insert(0, str(_validators_path))

from security.bash import validate
'''

FILE_TEST_IMPORTS = '''
# Import the validator
import sys
from pathlib import Path

# Add validators to path - find primitives relative to this test file
_test_dir = Path(__file__).parent
_repo_root = _test_dir
while _repo_root.name != "agentic-primitives" and _repo_root != _repo_root.parent:
    _repo_root = _repo_root.parent
_validators_path = _repo_root / "primitives" / "v1" / "hooks" / "validators"
if _validators_path.exists():
    sys.path.insert(0, str(_validators_path))

from security.file import validate, check_file_pattern, check_content_sensitive
'''

PII_TEST_IMPORTS = '''
# Import the validator
import sys
from pathlib import Path

# Add validators to path - find primitives relative to this test file
_test_dir = Path(__file__).parent
_repo_root = _test_dir
while _repo_root.name != "agentic-primitives" and _repo_root != _repo_root.parent:
    _repo_root = _repo_root.parent
_validators_path = _repo_root / "primitives" / "v1" / "hooks" / "validators"
if _validators_path.exists():
    sys.path.insert(0, str(_validators_path))

from prompt.pii import validate
'''


def load_patterns(file_path: Path) -> dict[str, Any]:
    """Load patterns from YAML file."""
    with open(file_path) as f:
        return yaml.safe_load(f)


def generate_bash_tests(patterns: dict[str, Any]) -> str:
    """Generate test code for bash patterns."""
    tests = []

    # Blocked patterns tests
    blocked = patterns.get("blocked", [])
    for pattern in blocked:
        pattern_id = pattern.get("id", "unknown")
        test_cases = pattern.get("test_cases", [])
        description = pattern.get("description", "")

        if not test_cases:
            continue

        # Generate test function
        test_name = f"test_blocked_{pattern_id.replace('-', '_')}"
        tests.append(f'''
class Test{pattern_id.replace("-", "_").title().replace("_", "")}:
    """Tests for pattern: {description}"""
''')

        for i, case in enumerate(test_cases):
            input_val = case.get("input", "")
            expected = case.get("expected", "")

            # Escape the input for Python string
            escaped_input = input_val.replace("\\", "\\\\").replace('"', '\\"')

            if expected == "blocked":
                tests.append(f'''
    def test_case_{i + 1}_blocked(self):
        """Test that '{escaped_input[:50]}...' is blocked"""
        result = validate({{"command": "{escaped_input}"}})
        assert result["safe"] is False, f"Expected blocked, got {{result}}"
        assert "blocked" in result.get("reason", "").lower() or "dangerous" in result.get("reason", "").lower()
''')
            elif expected == "allowed":
                tests.append(f'''
    def test_case_{i + 1}_allowed(self):
        """Test that '{escaped_input[:50]}...' is allowed"""
        result = validate({{"command": "{escaped_input}"}})
        assert result["safe"] is True, f"Expected allowed, got {{result}}"
''')

    # Suspicious patterns tests
    suspicious = patterns.get("suspicious", [])
    for pattern in suspicious:
        pattern_id = pattern.get("id", "unknown")
        test_cases = pattern.get("test_cases", [])
        description = pattern.get("description", "")

        if not test_cases:
            continue

        tests.append(f'''
class TestSuspicious{pattern_id.replace("-", "_").title().replace("_", "")}:
    """Tests for suspicious pattern: {description}"""
''')

        for i, case in enumerate(test_cases):
            input_val = case.get("input", "")
            expected = case.get("expected", "")
            escaped_input = input_val.replace("\\", "\\\\").replace('"', '\\"')

            if expected == "suspicious":
                tests.append(f'''
    def test_case_{i + 1}_suspicious(self):
        """Test that '{escaped_input[:50]}...' is flagged as suspicious"""
        result = validate({{"command": "{escaped_input}"}})
        # Suspicious patterns don't block, but add metadata
        assert result["safe"] is True
        metadata = result.get("metadata")
        assert metadata is not None, "Expected metadata for suspicious command"
        suspicious_patterns = metadata.get("suspicious_patterns", [])
        assert len(suspicious_patterns) > 0, "Expected suspicious patterns in metadata"
''')
            elif expected == "allowed":
                tests.append(f'''
    def test_case_{i + 1}_clean(self):
        """Test that '{escaped_input[:50]}...' has no suspicious flags"""
        result = validate({{"command": "{escaped_input}"}})
        assert result["safe"] is True
''')

    return "".join(tests)


def generate_file_tests(patterns: dict[str, Any]) -> str:
    """Generate test code for file patterns."""
    tests = []

    # Sensitive file patterns tests
    sensitive_files = patterns.get("sensitive_file_patterns", [])
    for pattern in sensitive_files:
        pattern_id = pattern.get("id", "unknown")
        test_cases = pattern.get("test_cases", [])
        description = pattern.get("description", "")

        if not test_cases:
            continue

        tests.append(f'''
class TestSensitiveFile{pattern_id.replace("-", "_").title().replace("_", "")}:
    """Tests for sensitive file pattern: {description}"""
''')

        for i, case in enumerate(test_cases):
            input_val = case.get("input", "")
            expected = case.get("expected", "")
            escaped_input = input_val.replace("\\", "\\\\").replace('"', '\\"')

            if expected == "blocked":
                tests.append(f'''
    def test_case_{i + 1}_blocked(self):
        """Test that '{escaped_input}' is detected as sensitive"""
        is_sensitive, reason = check_file_pattern("{escaped_input}")
        assert is_sensitive is True, f"Expected sensitive, got {{reason}}"
''')
            elif expected == "allowed":
                tests.append(f'''
    def test_case_{i + 1}_allowed(self):
        """Test that '{escaped_input}' is not detected as sensitive"""
        is_sensitive, reason = check_file_pattern("{escaped_input}")
        assert is_sensitive is False, f"Expected not sensitive, got {{reason}}"
''')

    # Sensitive content patterns tests
    content_patterns = patterns.get("sensitive_content_patterns", [])
    for pattern in content_patterns:
        pattern_id = pattern.get("id", "unknown")
        test_cases = pattern.get("test_cases", [])
        description = pattern.get("description", "")

        if not test_cases:
            continue

        tests.append(f'''
class TestSensitiveContent{pattern_id.replace("-", "_").title().replace("_", "")}:
    """Tests for sensitive content pattern: {description}"""
''')

        for i, case in enumerate(test_cases):
            input_val = case.get("input", "")
            expected = case.get("expected", "")
            escaped_input = input_val.replace("\\", "\\\\").replace('"', '\\"')

            if expected == "blocked":
                tests.append(f'''
    def test_case_{i + 1}_blocked(self):
        """Test that content containing '{escaped_input[:30]}...' is detected"""
        is_sensitive, reason, _ = check_content_sensitive("{escaped_input}")
        assert is_sensitive is True, f"Expected sensitive content, got {{reason}}"
''')
            elif expected == "allowed":
                tests.append(f'''
    def test_case_{i + 1}_allowed(self):
        """Test that content '{escaped_input[:30]}...' is not flagged"""
        is_sensitive, reason, _ = check_content_sensitive("{escaped_input}")
        assert is_sensitive is False, f"Expected not sensitive, got {{reason}}"
''')

    return "".join(tests)


def generate_pii_tests(patterns: dict[str, Any]) -> str:
    """Generate test code for PII patterns."""
    tests = []

    # PII patterns tests
    pii_patterns = patterns.get("pii_patterns", [])
    for pattern in pii_patterns:
        pattern_id = pattern.get("id", "unknown")
        test_cases = pattern.get("test_cases", [])
        description = pattern.get("description", "")
        risk_level = pattern.get("risk_level", "medium")

        if not test_cases:
            continue

        tests.append(f'''
class TestPII{pattern_id.replace("-", "_").title().replace("_", "")}:
    """Tests for PII pattern: {description} (risk: {risk_level})"""
''')

        for i, case in enumerate(test_cases):
            input_val = case.get("input", "")
            expected = case.get("expected", "")
            escaped_input = input_val.replace("\\", "\\\\").replace('"', '\\"')

            if expected == "blocked":
                tests.append(f'''
    def test_case_{i + 1}_detected(self):
        """Test that '{escaped_input[:30]}...' is detected as PII"""
        result = validate({{"prompt": "{escaped_input}"}})
        # High risk PII should be blocked
        if "{risk_level}" == "high":
            assert result["safe"] is False, f"Expected blocked for high-risk PII, got {{result}}"
        else:
            # Medium/low risk should be detected in metadata
            metadata = result.get("metadata")
            assert metadata is not None, "Expected metadata"
            detected = metadata.get("detected_pii", [])
            assert len(detected) > 0, "Expected PII detection in metadata"
''')
            elif expected == "suspicious":
                tests.append(f'''
    def test_case_{i + 1}_suspicious(self):
        """Test that '{escaped_input[:30]}...' is flagged in metadata"""
        result = validate({{"prompt": "{escaped_input}"}})
        metadata = result.get("metadata")
        # Should be detected but not necessarily blocked
        if metadata:
            detected = metadata.get("detected_pii", [])
            # Check detection or context
            assert len(detected) > 0 or metadata.get("detected_context"), f"Expected detection, got {{metadata}}"
''')
            elif expected == "allowed":
                tests.append(f'''
    def test_case_{i + 1}_allowed(self):
        """Test that '{escaped_input[:30]}...' is not flagged as PII"""
        result = validate({{"prompt": "{escaped_input}"}})
        assert result["safe"] is True
''')

    # Context patterns tests
    context_patterns = patterns.get("context_patterns", [])
    for pattern in context_patterns:
        pattern_id = pattern.get("id", "unknown")
        description = pattern.get("description", "")

        tests.append(f'''
class TestContext{pattern_id.replace("-", "_").title().replace("_", "")}:
    """Tests for context pattern: {description}"""

    def test_context_detection(self):
        """Test that context pattern is detected"""
        # Context patterns raise awareness but don't block
        pass  # Context patterns tested via integration tests
''')

    return "".join(tests)


def generate_test_file(pattern_type: str, output_dir: Path, dry_run: bool = False) -> str | None:
    """Generate a test file for the given pattern type."""
    if pattern_type not in PATTERN_FILES:
        print(f"Unknown pattern type: {pattern_type}")
        return None

    pattern_file = Path(PATTERN_FILES[pattern_type])
    if not pattern_file.exists():
        print(f"Pattern file not found: {pattern_file}")
        return None

    patterns = load_patterns(pattern_file)

    # Generate imports based on type
    if pattern_type == "bash":
        imports = BASH_TEST_IMPORTS
        tests = generate_bash_tests(patterns)
    elif pattern_type == "file":
        imports = FILE_TEST_IMPORTS
        tests = generate_file_tests(patterns)
    elif pattern_type == "pii":
        imports = PII_TEST_IMPORTS
        tests = generate_pii_tests(patterns)
    else:
        return None

    # Build full test file
    header = TEST_FILE_HEADER.format(
        pattern_name=pattern_type.upper(),
        timestamp=datetime.now().isoformat()
    )

    content = header + imports + tests

    # Output
    output_file = output_dir / f"test_{pattern_type}_patterns_generated.py"

    if dry_run:
        print(f"\n{'='*60}")
        print(f"Would write to: {output_file}")
        print(f"{'='*60}")
        print(content[:2000] + "..." if len(content) > 2000 else content)
        return content

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file.write_text(content)
    print(f"âœ… Generated: {output_file}")
    return content


def main():
    parser = argparse.ArgumentParser(description="Generate tests from pattern YAML files")
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("tests/generated/patterns"),
        help="Output directory for generated tests"
    )
    parser.add_argument(
        "--pattern",
        choices=["bash", "file", "pii", "all"],
        default="all",
        help="Pattern type to generate tests for"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print generated tests without writing files"
    )

    args = parser.parse_args()

    patterns_to_generate = list(PATTERN_FILES.keys()) if args.pattern == "all" else [args.pattern]

    print(f"ğŸ”§ Generating pattern tests...")
    print(f"   Output directory: {args.output}")
    print(f"   Patterns: {', '.join(patterns_to_generate)}")
    print()

    for pattern_type in patterns_to_generate:
        generate_test_file(pattern_type, args.output, args.dry_run)

    if not args.dry_run:
        # Create __init__.py
        init_file = args.output / "__init__.py"
        init_file.write_text('"""Generated pattern tests."""\n')

        print()
        print("âœ¨ Test generation complete!")
        print(f"   Run tests with: pytest {args.output} -v")


if __name__ == "__main__":
    main()
