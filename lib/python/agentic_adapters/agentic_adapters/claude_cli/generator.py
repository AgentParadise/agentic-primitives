"""Generate .claude/hooks/ Python files for Claude CLI.

Supports two observability backends:
- "events": Uses agentic_events for JSONL event emission (recommended)
- "jsonl": Legacy JSONL file logging
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Any

# Pre-tool-use hook template
PRE_TOOL_USE_TEMPLATE = '''#!/usr/bin/env python3
"""Pre-tool-use hook for Claude CLI.

Generated by agentic-adapters. Validates tool calls before execution.
"""

import json
import sys
from typing import Any

{security_imports}

{security_policy_code}

def validate_tool(tool_name: str, tool_input: dict[str, Any]) -> dict[str, Any]:
    """Validate a tool call and return decision."""
{validation_code}

def main() -> None:
    """Hook entry point - reads from stdin, writes to stdout."""
    # Read hook input from stdin
    hook_input = json.loads(sys.stdin.read())

    tool_name = hook_input.get("tool_name", "")
    tool_input = hook_input.get("tool_input", {{}})

    # Validate
    result = validate_tool(tool_name, tool_input)

    # Write decision to stdout
    print(json.dumps(result))


if __name__ == "__main__":
    main()
'''

# Post-tool-use hook template
POST_TOOL_USE_TEMPLATE = '''#!/usr/bin/env python3
"""Post-tool-use hook for Claude CLI.

Generated by agentic-adapters. Records tool execution for observability.
"""

import json
import sys
from typing import Any

{observability_imports}

{observability_setup}

def record_tool_use(
    tool_name: str,
    tool_input: dict[str, Any],
    tool_result: Any,
    error: str | None,
    session_id: str | None,
    tool_use_id: str | None,
) -> None:
    """Record tool execution."""
{recording_code}

def main() -> None:
    """Hook entry point - reads from stdin."""
    # Read hook input from stdin
    hook_input = json.loads(sys.stdin.read())

    tool_name = hook_input.get("tool_name", "")
    tool_input = hook_input.get("tool_input", {{}})
    tool_result = hook_input.get("tool_result")
    error = hook_input.get("error")
    session_id = hook_input.get("session_id")
    tool_use_id = hook_input.get("tool_use_id")

    # Record
    record_tool_use(tool_name, tool_input, tool_result, error, session_id, tool_use_id)


if __name__ == "__main__":
    main()
'''


@dataclass
class HookTemplate:
    """Configuration for hook generation."""

    # Security
    security_enabled: bool = True
    blocked_paths: list[str] | None = None
    blocked_commands: list[tuple[str, str]] | None = None

    # Observability
    observability_enabled: bool = True
    observability_backend: str = "events"  # "events" (recommended), "jsonl", "http"
    jsonl_path: str = ".agentic/analytics/events.jsonl"

    # Output
    make_executable: bool = True


def _generate_security_code(template: HookTemplate) -> tuple[str, str, str]:
    """Generate security validation code."""
    if not template.security_enabled:
        return "", "", "    return {'decision': 'allow'}"

    imports = "from agentic_security import SecurityPolicy"

    # Policy configuration
    policy_lines = ["policy = SecurityPolicy.with_defaults()"]

    if template.blocked_paths:
        paths_str = repr(template.blocked_paths)
        policy_lines.append(f"policy.blocked_paths.extend({paths_str})")

    if template.blocked_commands:
        cmds_str = repr(template.blocked_commands)
        policy_lines.append(f"policy.blocked_bash_patterns.extend({cmds_str})")

    policy_code = "\n".join(policy_lines)

    validation = """    result = policy.validate(tool_name, tool_input)

    if not result.safe:
        return {
            "decision": "block",
            "reason": result.reason or "Security policy violation",
        }

    return {"decision": "allow"}"""

    return imports, policy_code, validation


def _generate_observability_code(template: HookTemplate) -> tuple[str, str, str]:
    """Generate observability recording code."""
    if not template.observability_enabled:
        return "", "", "    pass  # Observability disabled"

    if template.observability_backend == "events":
        # agentic_events based observability (recommended)
        imports = """import os
from agentic_events import EventEmitter"""

        setup = '''# Event emitter (writes JSONL to stdout, captured by agent runner)
_emitter = None

def _get_emitter(session_id: str | None = None):
    global _emitter
    if _emitter is None:
        _emitter = EventEmitter(
            session_id=session_id or os.getenv("CLAUDE_SESSION_ID", "unknown"),
            provider="claude",
        )
    return _emitter'''

        recording = """    emitter = _get_emitter(session_id)
    emitter.tool_completed(
        tool_name=tool_name,
        tool_use_id=tool_use_id or "unknown",
        success=error is None,
        error=error,
    )"""

    elif template.observability_backend == "jsonl":
        imports = """import os
from pathlib import Path
from datetime import datetime, UTC"""

        setup = f'''# JSONL output path
EVENTS_PATH = Path("{template.jsonl_path}")
EVENTS_PATH.parent.mkdir(parents=True, exist_ok=True)'''

        recording = """    event = {
        "type": "tool_completed",
        "timestamp": datetime.now(UTC).isoformat(),
        "tool_name": tool_name,
        "success": error is None,
        "error": error,
    }

    with open(EVENTS_PATH, "a") as f:
        f.write(json.dumps(event) + "\\n")"""

    elif template.observability_backend == "http":
        imports = """import urllib.request
from datetime import datetime, UTC"""

        setup = '''# HTTP endpoint
ENDPOINT = os.environ.get("AGENTIC_EVENTS_ENDPOINT", "http://localhost:8080/events")'''

        recording = """    event = {
        "type": "tool_completed",
        "timestamp": datetime.now(UTC).isoformat(),
        "tool_name": tool_name,
        "success": error is None,
        "error": error,
    }

    try:
        req = urllib.request.Request(
            ENDPOINT,
            data=json.dumps(event).encode(),
            headers={"Content-Type": "application/json"},
            method="POST",
        )
        urllib.request.urlopen(req, timeout=5)
    except Exception:
        pass  # Non-blocking"""

    else:
        imports = ""
        setup = ""
        recording = "    pass  # Unknown backend"

    return imports, setup, recording


def generate_pre_tool_use_hook(template: HookTemplate | None = None) -> str:
    """Generate pre-tool-use hook Python code.

    Args:
        template: Hook configuration

    Returns:
        Python source code for the hook
    """
    if template is None:
        template = HookTemplate()

    imports, policy_code, validation = _generate_security_code(template)

    return PRE_TOOL_USE_TEMPLATE.format(
        security_imports=imports,
        security_policy_code=policy_code,
        validation_code=validation,
    )


def generate_post_tool_use_hook(template: HookTemplate | None = None) -> str:
    """Generate post-tool-use hook Python code.

    Args:
        template: Hook configuration

    Returns:
        Python source code for the hook
    """
    if template is None:
        template = HookTemplate()

    imports, setup, recording = _generate_observability_code(template)

    return POST_TOOL_USE_TEMPLATE.format(
        observability_imports=imports,
        observability_setup=setup,
        recording_code=recording,
    )


def generate_hooks(
    output_dir: str | Path,
    *,
    template: HookTemplate | None = None,
    security_enabled: bool = True,
    observability_enabled: bool = True,
    observability_backend: str = "events",
    **kwargs: Any,
) -> list[Path]:
    """Generate Claude CLI hook files.

    Args:
        output_dir: Directory to write hooks (e.g., ".claude/hooks")
        template: Full configuration (or use params below)
        security_enabled: Generate security hooks
        observability_enabled: Generate observability hooks
        observability_backend: Backend type ("events", "jsonl", "http")
        **kwargs: Additional template options

    Returns:
        List of generated file paths
    """
    if template is None:
        template = HookTemplate(
            security_enabled=security_enabled,
            observability_enabled=observability_enabled,
            observability_backend=observability_backend,
            **kwargs,
        )

    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    generated_files: list[Path] = []

    # Generate pre-tool-use hook (security)
    if template.security_enabled:
        pre_hook_path = output_path / "pre_tool_use.py"
        pre_hook_code = generate_pre_tool_use_hook(template)
        pre_hook_path.write_text(pre_hook_code)

        if template.make_executable:
            pre_hook_path.chmod(0o755)

        generated_files.append(pre_hook_path)

    # Generate post-tool-use hook (observability)
    if template.observability_enabled:
        post_hook_path = output_path / "post_tool_use.py"
        post_hook_code = generate_post_tool_use_hook(template)
        post_hook_path.write_text(post_hook_code)

        if template.make_executable:
            post_hook_path.chmod(0o755)

        generated_files.append(post_hook_path)

    return generated_files
