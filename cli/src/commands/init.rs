//! Initialize a new agentic-primitives repository

use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

const PRIMITIVES_CONFIG: &str = r#"# Agentic Primitives Configuration
# Generated by agentic-primitives CLI

spec_version: "v1"

paths:
  specs: "specs/v1"
  primitives: "primitives/v1"
  experimental: "primitives/experimental"
  providers: "providers"

validation:
  enabled: true
  layers:
    - structural
    - schema
    - semantic
  on_error: fail

hooks:
  enabled: true
  execution: pipeline
  timeout_sec: 30

providers:
  claude:
    models_dir: "providers/claude/models"
    output_dir: ".claude"
  openai:
    models_dir: "providers/openai/models"
    output_dir: ".openai"
  cursor:
    models_dir: "providers/cursor/models"
    output_dir: ".cursor"
"#;

const README: &str = r#"# Agentic Primitives Repository

This repository contains reusable AI primitives for coding agents.

## Structure

```
â”œâ”€â”€ specs/v1/              # JSON schemas for v1 primitives
â”œâ”€â”€ primitives/v1/         # Versioned primitives
â”‚   â”œâ”€â”€ prompts/
â”‚   â”‚   â”œâ”€â”€ agents/        # System-level prompts
â”‚   â”‚   â”œâ”€â”€ commands/      # User-facing commands
â”‚   â”‚   â”œâ”€â”€ skills/        # Overlay knowledge
â”‚   â”‚   â””â”€â”€ meta-prompts/  # Prompt generators
â”‚   â”œâ”€â”€ tools/             # Executable capabilities
â”‚   â””â”€â”€ hooks/             # Lifecycle middleware
â”œâ”€â”€ primitives/experimental/  # Sandbox for v2+ ideas
â”œâ”€â”€ providers/             # Provider-specific configurations
â”‚   â”œâ”€â”€ claude/
â”‚   â”œâ”€â”€ openai/
â”‚   â””â”€â”€ cursor/
â””â”€â”€ docs/                  # Documentation
    â””â”€â”€ adrs/              # Architecture Decision Records
```

## Getting Started

### Create a new primitive

```bash
# Create an agent
agentic-p new prompt agents <category> <id> --kind agent

# Create a command
agentic-p new prompt commands <category> <id> --kind command

# Create a tool
agentic-p new tool <category> <id>

# Create a hook
agentic-p new hook <category> <id>
```

### Validate primitives

```bash
# Validate all primitives
agentic-p validate primitives/v1/

# Validate specific primitive
agentic-p validate primitives/v1/prompts/agents/<category>/<id>

# Validate with specific layer
agentic-p validate --layer structural primitives/v1/
```

### Build for providers

```bash
# Build for Claude
agentic-p build --provider claude

# Build for OpenAI
agentic-p build --provider openai
```

## Documentation

- [Getting Started](docs/getting-started.md)
- [Architecture](docs/architecture.md)
- [Versioning Guide](docs/versioning-guide.md)
- [ADRs](docs/adrs/)

## License

MIT
"#;

const GITIGNORE: &str = r#"# Build outputs
/build/
/.claude/
/.openai/
/.cursor/

# Dependencies
node_modules/
.pnpm-store/
__pycache__/
*.pyc
.venv/
venv/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Temporary files
*.tmp
*.log
.cache/

# Rust (if using Rust tools)
target/
Cargo.lock

# Project plans (don't commit)
PROJECT-PLAN_*.md
WAVE-*.md
"#;

const EXPERIMENTAL_README: &str = r#"# Experimental Primitives Workspace

This directory is a sandbox for testing v2+ architectural ideas.

## Purpose

Use this space to:
- Experiment with new primitive structures
- Test alternative schema designs
- Prototype features before committing to v2
- Iterate rapidly without breaking v1

## Rules

- Primitives here can break, change, or be deleted at any time
- No validation guarantees (structural validation only)
- Not suitable for production use
- Promoted to v2 when stable

## Workflow

1. **Create** experimental primitive:
   ```bash
   agentic-p new <type> <category> <id> --experimental
   ```

2. **Test** with lenient validation:
   ```bash
   agentic-p validate primitives/experimental/ --spec-version experimental
   ```

3. **Iterate** freely - make changes without worrying about compatibility

4. **Promote** when stable:
   - Document in ADR
   - Create `/specs/v2/` schemas
   - Move to `/primitives/v2/`
   - Update CLI for v2 support

## Examples

Some ideas worth experimenting with:
- Claude-specific prompt optimizations
- Tool composition patterns
- Multi-agent coordination primitives
- New hook event types
- Alternative metadata structures

**Remember**: This is a playground. Break things. Learn. Iterate.
"#;

/// Initialize a new agentic-primitives repository
pub fn init(path: &Path) -> Result<()> {
    println!("ğŸš€ Initializing agentic-primitives repository at {path:?}\n");

    // 1. Check if directory exists, create if needed
    if !path.exists() {
        fs::create_dir_all(path)
            .with_context(|| format!("Failed to create directory: {path:?}"))?;
    }

    // 2. Check if already initialized
    let config_path = path.join("primitives.config.yaml");
    if config_path.exists() {
        anyhow::bail!("Directory already initialized at {path:?}");
    }

    // 3. Create directory structure
    create_directory_structure(path)?;

    // 4. Copy embedded JSON schemas
    copy_embedded_schemas(path)?;

    // 5. Generate primitives.config.yaml
    fs::write(&config_path, PRIMITIVES_CONFIG)
        .with_context(|| format!("Failed to write config: {config_path:?}"))?;

    // 6. Generate README.md
    fs::write(path.join("README.md"), README).with_context(|| "Failed to write README.md")?;

    // 7. Generate .gitignore
    fs::write(path.join(".gitignore"), GITIGNORE).with_context(|| "Failed to write .gitignore")?;

    // 8. Create experimental README
    fs::write(
        path.join("primitives/experimental/README.md"),
        EXPERIMENTAL_README,
    )
    .with_context(|| "Failed to write experimental README")?;

    // 9. Print success message
    print_success_message(path)?;

    Ok(())
}

fn create_directory_structure(base: &Path) -> Result<()> {
    let dirs = vec![
        "specs/v1",
        "primitives/v1/prompts/agents",
        "primitives/v1/prompts/commands",
        "primitives/v1/prompts/skills",
        "primitives/v1/prompts/meta-prompts",
        "primitives/v1/tools",
        "primitives/v1/hooks",
        "primitives/experimental",
        "providers/claude/models",
        "providers/openai/models",
        "providers/cursor/models",
        "docs/adrs",
    ];

    for dir in dirs {
        let dir_path = base.join(dir);
        fs::create_dir_all(&dir_path)
            .with_context(|| format!("Failed to create directory: {dir_path:?}"))?;
    }

    Ok(())
}

fn copy_embedded_schemas(base: &Path) -> Result<()> {
    let schema_dir = base.join("specs/v1");

    // Embedded schemas from the binary
    let schemas = vec![
        (
            "prompt-meta.schema.json",
            include_str!("../../../specs/v1/prompt-meta.schema.json"),
        ),
        (
            "tool-meta.schema.json",
            include_str!("../../../specs/v1/tool-meta.schema.json"),
        ),
        (
            "hook-meta.schema.json",
            include_str!("../../../specs/v1/hook-meta.schema.json"),
        ),
        (
            "model-config.schema.json",
            include_str!("../../../specs/v1/model-config.schema.json"),
        ),
        (
            "provider-impl.schema.json",
            include_str!("../../../specs/v1/provider-impl.schema.json"),
        ),
    ];

    for (name, content) in schemas {
        fs::write(schema_dir.join(name), content)
            .with_context(|| format!("Failed to write schema: {name}"))?;
    }

    Ok(())
}

fn print_success_message(path: &Path) -> Result<()> {
    use colored::Colorize;

    println!(
        "{}",
        "âœ¨ Successfully initialized repository!".green().bold()
    );
    println!();
    println!("ğŸ“ {}", "Created directory structure:".bold());
    println!("  â”œâ”€â”€ specs/v1/ {} schemas", "(5".dimmed());
    println!("  â”œâ”€â”€ primitives/v1/ {} subdirectories", "(6".dimmed());
    println!("  â”œâ”€â”€ primitives/experimental/");
    println!("  â”œâ”€â”€ providers/");
    println!("  â””â”€â”€ docs/adrs/");
    println!();
    println!("ğŸ“„ {}", "Generated files:".bold());
    println!("  â”œâ”€â”€ primitives.config.yaml");
    println!("  â”œâ”€â”€ README.md");
    println!("  â””â”€â”€ .gitignore");
    println!();
    println!("{}", "ğŸš€ Next steps:".bold());
    println!("  1. {}", format!("cd {}", path.display()).cyan());
    println!(
        "  2. {}",
        "agentic-p new prompt agents <category> <id>".cyan()
    );
    println!("  3. {}", "agentic-p validate primitives/v1/".cyan());
    println!();
    println!("Run {} for more commands.", "'agentic-p --help'".yellow());

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_init_creates_directory_structure() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        let result = init(path);
        assert!(result.is_ok(), "init should succeed");

        // Check directories
        assert!(path.join("specs/v1").exists());
        assert!(path.join("primitives/v1/prompts/agents").exists());
        assert!(path.join("primitives/v1/prompts/commands").exists());
        assert!(path.join("primitives/v1/prompts/skills").exists());
        assert!(path.join("primitives/v1/prompts/meta-prompts").exists());
        assert!(path.join("primitives/v1/tools").exists());
        assert!(path.join("primitives/v1/hooks").exists());
        assert!(path.join("primitives/experimental").exists());
        assert!(path.join("providers/claude/models").exists());
        assert!(path.join("providers/openai/models").exists());
        assert!(path.join("docs/adrs").exists());
    }

    #[test]
    fn test_init_creates_config_file() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        init(path).unwrap();

        let config_path = path.join("primitives.config.yaml");
        assert!(config_path.exists());

        let content = fs::read_to_string(config_path).unwrap();
        assert!(content.contains("spec_version: \"v1\""));
        assert!(content.contains("specs: \"specs/v1\""));
        assert!(content.contains("primitives: \"primitives/v1\""));
    }

    #[test]
    fn test_init_creates_schemas() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        init(path).unwrap();

        // Check all 5 schemas exist
        assert!(path.join("specs/v1/prompt-meta.schema.json").exists());
        assert!(path.join("specs/v1/tool-meta.schema.json").exists());
        assert!(path.join("specs/v1/hook-meta.schema.json").exists());
        assert!(path.join("specs/v1/model-config.schema.json").exists());
        assert!(path.join("specs/v1/provider-impl.schema.json").exists());
    }

    #[test]
    fn test_init_creates_readme() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        init(path).unwrap();

        let readme_path = path.join("README.md");
        assert!(readme_path.exists());

        let content = fs::read_to_string(readme_path).unwrap();
        assert!(content.contains("Agentic Primitives Repository"));
        assert!(content.contains("## Getting Started"));
    }

    #[test]
    fn test_init_creates_gitignore() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        init(path).unwrap();

        let gitignore_path = path.join(".gitignore");
        assert!(gitignore_path.exists());

        let content = fs::read_to_string(gitignore_path).unwrap();
        assert!(content.contains("# Build outputs"));
        assert!(content.contains("/.claude/"));
    }

    #[test]
    fn test_init_creates_experimental_readme() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        init(path).unwrap();

        let exp_readme = path.join("primitives/experimental/README.md");
        assert!(exp_readme.exists());

        let content = fs::read_to_string(exp_readme).unwrap();
        assert!(content.contains("Experimental Primitives Workspace"));
    }

    #[test]
    fn test_init_fails_if_already_initialized() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        // Initialize once
        init(path).unwrap();

        // Try to initialize again
        let result = init(path);
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("already initialized"));
    }

    #[test]
    fn test_init_creates_nonexistent_directory() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path().join("new-repo");

        assert!(!path.exists());

        init(&path).unwrap();

        assert!(path.exists());
        assert!(path.join("primitives.config.yaml").exists());
    }
}
