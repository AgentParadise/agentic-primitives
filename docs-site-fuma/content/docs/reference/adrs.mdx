---
title: Architecture Decision Records
description: Technical decisions and their rationale
---

## What Are ADRs?

Architecture Decision Records (ADRs) document significant technical decisions in the project. Each ADR captures:

- **Context**: Why the decision was needed
- **Decision**: What was decided
- **Consequences**: Trade-offs and implications

## ADR Index

| ADR | Title | Status |
|-----|-------|--------|
| [ADR-001](#adr-001-staged-bootstrap-strategy) | Staged Bootstrap Strategy | Accepted |
| [ADR-002](#adr-002-strict-validation) | Strict Validation | Accepted |
| [ADR-003](#adr-003-non-interactive-scaffolding) | Non-Interactive Scaffolding | Accepted |
| [ADR-004](#adr-004-provider-scoped-models) | Provider-Scoped Models | Accepted |
| [ADR-005](#adr-005-polyglot-implementations) | Polyglot Implementations | Accepted |
| [ADR-006](#adr-006-middleware-based-hooks) | Middleware-Based Hooks | Accepted |
| [ADR-007](#adr-007-generated-provider-outputs) | Generated Provider Outputs | Accepted |
| [ADR-008](#adr-008-test-driven-development) | Test-Driven Development | Accepted |
| [ADR-009](#adr-009-versioned-primitives) | Versioned Primitives | Accepted |
| [ADR-010](#adr-010-system-level-versioning) | System-Level Versioning | Accepted |

---

## ADR-001: Staged Bootstrap Strategy

### Context
Building a CLI tool that manages primitives requires careful sequencing of features. A big-bang approach risks complexity and incomplete validation.

### Decision
Implement in three stages:
1. **Foundation**: Core primitives structure and validation
2. **CLI**: Complete command set with full validation
3. **Providers**: Provider adapters and build system

### Consequences
- ✅ Each stage is fully testable before proceeding
- ✅ Early feedback on core design decisions
- ⚠️ Some refactoring needed between stages

---

## ADR-002: Strict Validation

### Context
Primitives must be reliable and consistent. Loose validation leads to hard-to-debug issues in production.

### Decision
Implement three-layer validation:
1. **Structural**: File organization, naming conventions
2. **Schema**: JSON Schema compliance for YAML files
3. **Semantic**: Cross-references, version integrity, hash verification

### Consequences
- ✅ Catches errors early in development
- ✅ Guarantees primitive consistency
- ⚠️ Stricter requirements for contributors
- ⚠️ Initial learning curve

---

## ADR-003: Non-Interactive Scaffolding

### Context
Interactive prompts in CLIs can be cumbersome for automation and scripting.

### Decision
All `agentic-p new` commands use flags/arguments, not interactive prompts. Configuration goes in files.

### Consequences
- ✅ Fully scriptable and automatable
- ✅ CI/CD friendly
- ✅ Consistent behavior
- ⚠️ Requires reading documentation for options

---

## ADR-004: Provider-Scoped Models

### Context
Different LLM providers have different models with different capabilities.

### Decision
Organize models under provider namespaces:
```
providers/models/anthropic/claude-4-sonnet.yaml
providers/models/openai/gpt-4.yaml
```

Reference as `anthropic/claude-4-sonnet`.

### Consequences
- ✅ Clear model provenance
- ✅ Provider-specific capabilities defined
- ✅ Easy to add new providers
- ⚠️ Longer model references

---

## ADR-005: Polyglot Implementations

### Context
Hooks and tools need implementations. Python is common but TypeScript and Rust have advantages.

### Decision
Support multiple runtimes:
- Python (primary, via UV)
- TypeScript (via Bun/Node)
- Rust (for performance-critical tools)

### Consequences
- ✅ Use the best language for each task
- ✅ Leverage existing ecosystems
- ⚠️ More complexity in build system
- ⚠️ Contributors need knowledge of chosen language

---

## ADR-006: Middleware-Based Hooks

### Context
Hooks need to be composable and chainable. A simple handler pattern doesn't scale.

### Decision
Hooks are middleware that can:
- Execute in order by priority
- Pass data to next middleware
- Short-circuit (block) the chain
- Modify inputs/outputs

### Consequences
- ✅ Highly composable
- ✅ Familiar pattern (Express, Django)
- ✅ Separation of concerns
- ⚠️ More complex than simple handlers

---

## ADR-007: Generated Provider Outputs

### Context
Different providers need different output formats. Hand-maintaining multiple formats is error-prone.

### Decision
Generate all provider outputs from primitives:
- `agentic-p build --provider claude` generates `.claude/` structure
- `agentic-p build --provider openai` generates OpenAI format
- Manifest tracks what was generated

### Consequences
- ✅ Single source of truth
- ✅ Consistent outputs
- ✅ Easy to add providers
- ⚠️ Regeneration needed on primitive changes

---

## ADR-008: Test-Driven Development

### Context
Primitives are used in critical AI workflows. Bugs can have significant impact.

### Decision
- All CLI commands have E2E tests
- Validation logic has comprehensive unit tests
- Hooks require test fixtures
- Coverage target: 80%+

### Consequences
- ✅ High confidence in correctness
- ✅ Regression prevention
- ⚠️ Slower initial development
- ⚠️ Test maintenance overhead

---

## ADR-009: Versioned Primitives

### Context
Prompts evolve. Without versioning, changes are untraceable and rollbacks impossible.

### Decision
- Each primitive has a version registry in metadata
- Versions are immutable once promoted to active
- BLAKE3 hashes verify integrity
- Version lifecycle: draft → active → deprecated → archived

### Consequences
- ✅ Full change history
- ✅ Safe rollbacks
- ✅ Hash verification
- ⚠️ More files per primitive
- ⚠️ Need to manage versions explicitly

---

## ADR-010: System-Level Versioning

### Context
The primitive system itself evolves. Need to handle breaking changes in schema, structure, etc.

### Decision
Use system-level versions (`v1/`, `v2/`) for the primitive specification:
```
primitives/v1/...   # Current spec
primitives/v2/...   # Future breaking changes
specs/v1/...        # Current schemas
```

### Consequences
- ✅ Breaking changes don't affect existing primitives
- ✅ Migration path for upgrades
- ✅ Clear separation of concerns
- ⚠️ Potential duplication during transitions

---

## Full ADR Documentation

For complete ADR documentation with full context and discussion, see the [ADRs directory](https://github.com/AgentParadise/agentic-primitives/tree/main/docs/adrs) in the main repository.

## Writing New ADRs

When making significant technical decisions:

1. Create `docs/adrs/NNN-title.md`
2. Use the template:

```markdown
# ADR-NNN: Title

## Status
Proposed | Accepted | Deprecated | Superseded

## Context
What is the issue that we're seeing that motivates this decision?

## Decision
What is the change that we're proposing and/or doing?

## Consequences
What becomes easier or more difficult to do because of this change?
```

3. Submit PR for review
4. Update this index when merged
