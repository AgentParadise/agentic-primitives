---
title: Create a Hook
description: Build a security hook that blocks dangerous bash commands
---

import { Accordions, Accordion } from 'fumadocs-ui/components/accordion';
import { Cards, Card } from 'fumadocs-ui/components/card';
import { Callout } from 'fumadocs-ui/components/callout';

## What You'll Build

In this guide, you'll create a **Bash Validator Hook** ‚Äî a security middleware that intercepts bash commands and blocks dangerous operations.

<Callout type="info">
**Time:** ~15 minutes
**Prerequisites:** agentic-p installed, repository initialized, Python 3.11+
</Callout>

## What Are Hooks?

Hooks are **lifecycle event handlers** that intercept events during agent execution:

- **Security**: Block dangerous commands, protect sensitive files
- **Observability**: Log operations, emit metrics
- **Control**: Auto-approve safe operations, enforce policies

## Step 1: Create the Hook

```bash
agentic-p new hook security/bash-validator -d "Validates bash commands for dangerous operations"
```

This creates:
```
primitives/v1/hooks/security/bash-validator/
‚îú‚îÄ‚îÄ bash-validator.hook.yaml
‚îî‚îÄ‚îÄ middleware.py
```

## Step 2: Configure the Hook

Edit `bash-validator.hook.yaml`:

```yaml
spec_version: "v1"
type: hook
name: bash-validator
description: "Validates bash commands for dangerous operations"

# Which events trigger this hook
events:
  - PreToolUse

# What to do when triggered: block, warn, log, modify
action: block

# Match specific tools
matcher:
  tool_names:
    - Bash
    - Shell
    - Execute
    - Terminal

# Implementation details
implementation:
  runtime: python
  entrypoint: middleware.py
  dependencies:
    - pyyaml>=6.0

# Configuration that can be overridden per-agent
config:
  # Patterns that are always blocked
  blocked_patterns:
    - "rm -rf /"
    - "rm -rf /*"
    - "sudo rm -rf"
    - "> /dev/sda"
    - "mkfs."
    - "dd if=/dev/zero"
    - ":(){ :|:& };:"  # Fork bomb
    - "chmod -R 777 /"

  # Commands requiring confirmation
  warn_patterns:
    - "rm -rf"
    - "sudo"
    - "chmod 777"
    - "> /dev/"

  # Patterns that are always allowed (whitelist)
  allowed_patterns:
    - "rm -rf node_modules"
    - "rm -rf .cache"
    - "rm -rf __pycache__"
    - "rm -rf dist"
    - "rm -rf build"
```

## Step 3: Implement the Middleware

Edit `middleware.py`:

```python
#!/usr/bin/env python3
"""Bash command validator middleware."""

import json
import re
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Any


# Analytics file for audit logging
ANALYTICS_FILE = Path(".agentic/analytics/events.jsonl")


def load_config() -> dict:
    """Load hook configuration."""
    # Default configuration
    return {
        "blocked_patterns": [
            r"rm\s+-rf\s+/\s*$",
            r"rm\s+-rf\s+/\*",
            r"sudo\s+rm\s+-rf\s+/",
            r">\s*/dev/sda",
            r"mkfs\.",
            r"dd\s+if=/dev/zero",
            r":\(\)\{\s*:\|:&\s*\};:",
            r"chmod\s+-R\s+777\s+/",
        ],
        "warn_patterns": [
            r"rm\s+-rf",
            r"sudo\s+",
            r"chmod\s+777",
            r">\s*/dev/",
        ],
        "allowed_patterns": [
            r"rm\s+-rf\s+node_modules",
            r"rm\s+-rf\s+\.cache",
            r"rm\s+-rf\s+__pycache__",
            r"rm\s+-rf\s+dist",
            r"rm\s+-rf\s+build",
            r"rm\s+-rf\s+\.pytest_cache",
        ],
    }


def log_decision(event: dict, decision: dict) -> None:
    """Log hook decision to analytics file."""
    try:
        entry = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "hook": "bash-validator",
            "event_type": event.get("type"),
            "tool_name": event.get("tool_name"),
            "decision": decision.get("allow"),
            "reason": decision.get("message", ""),
        }

        ANALYTICS_FILE.parent.mkdir(parents=True, exist_ok=True)
        with ANALYTICS_FILE.open("a") as f:
            f.write(json.dumps(entry) + "\n")
    except Exception:
        # Never let analytics errors block execution
        pass


def is_allowed(command: str, config: dict) -> bool:
    """Check if command matches allowed patterns."""
    for pattern in config.get("allowed_patterns", []):
        if re.search(pattern, command, re.IGNORECASE):
            return True
    return False


def is_blocked(command: str, config: dict) -> tuple[bool, str]:
    """Check if command matches blocked patterns."""
    for pattern in config.get("blocked_patterns", []):
        if re.search(pattern, command, re.IGNORECASE):
            return True, f"Blocked pattern: {pattern}"
    return False, ""


def should_warn(command: str, config: dict) -> tuple[bool, str]:
    """Check if command matches warning patterns."""
    for pattern in config.get("warn_patterns", []):
        if re.search(pattern, command, re.IGNORECASE):
            return True, f"Warning pattern: {pattern}"
    return False, ""


def handle_pre_tool_use(event: dict[str, Any]) -> dict[str, Any]:
    """
    Handle PreToolUse events for bash commands.

    Args:
        event: Event data with tool_name and tool_input

    Returns:
        Response dict with 'allow' (bool) and optional 'message'
    """
    tool_name = event.get("tool_name", "")
    tool_input = event.get("tool_input", {})

    # Extract command from input
    command = tool_input.get("command", "")
    if not command:
        command = tool_input.get("cmd", "")
    if not command:
        command = str(tool_input)

    # Load configuration
    config = load_config()

    # Check allowed patterns first (whitelist)
    if is_allowed(command, config):
        decision = {"allow": True}
        log_decision(event, decision)
        return decision

    # Check blocked patterns
    blocked, reason = is_blocked(command, config)
    if blocked:
        decision = {
            "allow": False,
            "message": f"üõ°Ô∏è Blocked dangerous command: {command}\nReason: {reason}",
        }
        log_decision(event, decision)
        return decision

    # Check warning patterns
    warn, reason = should_warn(command, config)
    if warn:
        decision = {
            "allow": True,
            "warning": f"‚ö†Ô∏è Potentially dangerous command: {command}\nReason: {reason}",
        }
        log_decision(event, decision)
        return decision

    # Default: allow
    decision = {"allow": True}
    log_decision(event, decision)
    return decision


def main():
    """Main entry point for middleware."""
    # Read event from stdin
    event = json.loads(sys.stdin.read())

    # Handle based on event type
    event_type = event.get("type", "")

    if event_type == "PreToolUse":
        result = handle_pre_tool_use(event)
    else:
        # Unknown event type, allow by default
        result = {"allow": True}

    # Output result
    print(json.dumps(result))


if __name__ == "__main__":
    main()
```

## Step 4: Test the Hook Locally

```bash
# Test safe command
agentic-p test-hook security/bash-validator \
  --input '{"type": "PreToolUse", "tool_name": "Bash", "tool_input": {"command": "ls -la"}}'
# Expected: ALLOWED

# Test dangerous command
agentic-p test-hook security/bash-validator \
  --input '{"type": "PreToolUse", "tool_name": "Bash", "tool_input": {"command": "rm -rf /"}}'
# Expected: BLOCKED

# Test warning command
agentic-p test-hook security/bash-validator \
  --input '{"type": "PreToolUse", "tool_name": "Bash", "tool_input": {"command": "sudo apt update"}}'
# Expected: ALLOWED with WARNING

# Test whitelisted command
agentic-p test-hook security/bash-validator \
  --input '{"type": "PreToolUse", "tool_name": "Bash", "tool_input": {"command": "rm -rf node_modules"}}'
# Expected: ALLOWED
```

## Step 5: Create Test Fixtures

Create test fixtures for comprehensive testing:

```bash
mkdir -p tests/events/bash-validator
```

```json
// tests/events/bash-validator/safe-ls.json
{
  "type": "PreToolUse",
  "tool_name": "Bash",
  "tool_input": {
    "command": "ls -la /home/user"
  },
  "session_id": "test-123"
}
```

```json
// tests/events/bash-validator/dangerous-rm.json
{
  "type": "PreToolUse",
  "tool_name": "Bash",
  "tool_input": {
    "command": "rm -rf /"
  },
  "session_id": "test-123"
}
```

## Step 6: Validate and Build

```bash
# Validate
agentic-p validate

# Build for Claude
agentic-p build --provider claude

# Install
agentic-p install --provider claude --project
```

## Step 7: Verify Installation

Check that the hook is configured in `.claude/hooks/hooks.json`:

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "name": "bash-validator",
        "path": "./hooks/security/bash-validator.py",
        "matcher": {
          "tool_names": ["Bash", "Shell", "Execute", "Terminal"]
        }
      }
    ]
  }
}
```

## Advanced: Adding More Security Hooks

### File Security Hook

```bash
agentic-p new hook security/file-security
```

```python
# Protect sensitive files
SENSITIVE_PATTERNS = [
    r"\.env",
    r"\.ssh/",
    r"id_rsa",
    r"\.aws/credentials",
    r"/etc/passwd",
    r"/etc/shadow",
]

def handle_pre_tool_use(event: dict) -> dict:
    tool_input = event.get("tool_input", {})
    path = tool_input.get("path", "")

    for pattern in SENSITIVE_PATTERNS:
        if re.search(pattern, path):
            return {
                "allow": True,
                "warning": f"‚ö†Ô∏è Accessing sensitive file: {path}",
            }

    return {"allow": True}
```

### Prompt Filter Hook

```bash
agentic-p new hook security/prompt-filter
```

```python
# Detect PII in prompts
PII_PATTERNS = {
    "email": r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}",
    "api_key": r"(sk-|api[_-]?key)[a-zA-Z0-9]{20,}",
    "password": r"password\s*[:=]\s*\S+",
}
```

## Best Practices

<Accordions>
  <Accordion title="Fail-safe analytics">
    Never let analytics errors block hook execution. Wrap logging in try/except.
  </Accordion>
  <Accordion title="Whitelist over blacklist">
    When possible, whitelist safe patterns rather than just blocking dangerous ones.
  </Accordion>
  <Accordion title="Clear messages">
    Provide clear, actionable messages when blocking or warning.
  </Accordion>
  <Accordion title="Test extensively">
    Create comprehensive test fixtures for all patterns.
  </Accordion>
</Accordions>

## Next Steps

<Cards>
  <Card
    title="Deploy to Claude"
    href="/docs/guides/deploy-claude"
  >
    Deploy your primitives to Claude Code
  </Card>
  <Card
    title="Hooks Concepts"
    href="/docs/concepts/hooks"
  >
    Deep dive into hook architecture
  </Card>
</Cards>
