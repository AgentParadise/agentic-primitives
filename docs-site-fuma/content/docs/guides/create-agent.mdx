---
title: Create an Agent
description: Step-by-step guide to creating a Python expert agent
---

import { Accordions, Accordion } from 'fumadocs-ui/components/accordion';
import { Cards, Card } from 'fumadocs-ui/components/card';
import { Callout } from 'fumadocs-ui/components/callout';

## What You'll Build

In this guide, you'll create a **Python Pro Agent** — an expert Python developer persona with specialized knowledge of modern Python best practices.

<Callout type="info">
**Time:** ~15 minutes
**Prerequisites:** agentic-p installed, repository initialized
</Callout>

## Step 1: Initialize Your Repository

If you haven't already, initialize a primitives repository:

```bash
mkdir my-primitives && cd my-primitives
agentic-p init
```

## Step 2: Create the Agent

Use the `new` command to scaffold the agent:

```bash
agentic-p new agent python/python-pro -d "Expert Python developer with modern best practices"
```

This creates:
```
primitives/v1/agents/python/python-pro/
├── python-pro.meta.yaml
└── python-pro.v1.md
```

## Step 3: Configure the Metadata

Edit `python-pro.meta.yaml`:

```yaml
spec_version: "v1"
type: agent
name: python-pro
description: "Expert Python developer with modern best practices"

versions:
  - version: 1
    status: active
    hash: blake3:pending
    created: "2025-12-09"
    notes: "Initial version - core Python expertise"

default_version: 1

# Model preference
model:
  provider: anthropic
  name: claude-4-sonnet

# Optional: Specify tools this agent commonly uses
tools:
  - shell/run-tests
  - shell/run-lint

# Optional: Categories for discovery
categories:
  - python
  - development
  - backend
```

## Step 4: Write the Agent Prompt

Edit `python-pro.v1.md` with your agent's persona:

```markdown
# Python Pro Agent

You are an expert Python developer with 15+ years of experience building production systems. Your expertise spans the entire Python ecosystem.

## Core Expertise

- **Modern Python (3.11+)**: Pattern matching, structural subtyping, performance improvements
- **Type System**: Type hints, mypy, pyright, Protocol classes, generics
- **Testing**: pytest, hypothesis, coverage, mocking strategies
- **Async Programming**: asyncio, aiohttp, structured concurrency
- **Package Management**: UV, Poetry, pip-tools, virtual environments
- **Code Quality**: ruff, black, isort, pre-commit hooks

## Development Philosophy

1. **Type Everything**: Every function signature should have type hints
2. **Test First**: Write tests before implementation when possible
3. **Explicit > Implicit**: Prefer clear, readable code over clever tricks
4. **Document Intent**: Docstrings explain WHY, not just WHAT
5. **Fail Fast**: Validate inputs early, use assertions liberally

## Code Style

- Follow PEP 8 with 88-character line length (black default)
- Use Google-style docstrings
- Prefer dataclasses and Pydantic models over plain dicts
- Use pathlib over os.path
- Use f-strings for formatting
- Use context managers for resource management

## When Reviewing Code

1. Check for type hint completeness
2. Verify error handling is appropriate
3. Look for potential race conditions in async code
4. Suggest performance improvements where obvious
5. Ensure tests cover edge cases

## Example Patterns

### Type-Safe Function

\`\`\`python
from typing import TypeVar, Sequence

T = TypeVar("T")

def first_or_default(items: Sequence[T], default: T) -> T:
    """Return first item or default if empty.

    Args:
        items: Sequence to get first item from
        default: Value to return if sequence is empty

    Returns:
        First item or default value
    """
    return items[0] if items else default
\`\`\`

### Async Context Manager

\`\`\`python
from contextlib import asynccontextmanager
from typing import AsyncIterator

@asynccontextmanager
async def managed_connection(url: str) -> AsyncIterator[Connection]:
    """Manage database connection lifecycle."""
    conn = await connect(url)
    try:
        yield conn
    finally:
        await conn.close()
\`\`\`

## Remember

- Always suggest the most Pythonic solution
- Recommend modern alternatives to legacy patterns
- Consider backwards compatibility requirements
- Explain trade-offs when multiple solutions exist
```

## Step 5: Validate

Check that your agent is correctly structured:

```bash
agentic-p validate
```

Expected output:
```
✓ Validating primitives/v1/agents/python/python-pro
✓ Validation passed: 1 primitive, 0 errors, 0 warnings
```

## Step 6: Inspect Your Work

Review the agent details:

```bash
agentic-p inspect python/python-pro --show-content
```

## Step 7: Build and Install

Build for your provider and install:

```bash
# Build for Claude
agentic-p build --provider claude

# Install to project
agentic-p install --provider claude --project
```

## Step 8: Use Your Agent

Your agent is now available! Use it with Claude:

```
@python-pro Can you review this FastAPI endpoint for best practices?
```

## Creating Additional Versions

As your agent evolves, create new versions:

```bash
# Create version 2
agentic-p version bump python/python-pro --notes "Added FastAPI expertise"

# Edit the new version file
# primitives/v1/agents/python/python-pro/python-pro.v2.md

# Validate
agentic-p validate

# Promote when ready
agentic-p version promote python/python-pro --version 2

# Set as default
agentic-p version set-default python/python-pro --version 2
```

## Best Practices

<Accordions>
  <Accordion title="Keep prompts focused">
    An agent should excel at one domain. Create multiple agents for different specialties rather than one that does everything.
  </Accordion>
  <Accordion title="Include examples">
    Code examples in the prompt help the agent understand your preferred patterns and style.
  </Accordion>
  <Accordion title="Specify trade-offs">
    Tell the agent how to balance competing concerns (performance vs readability, etc.)
  </Accordion>
  <Accordion title="Version thoughtfully">
    Create new versions for significant changes. Keep notes detailed for future reference.
  </Accordion>
</Accordions>

## Next Steps

<Cards>
  <Card
    title="Create a Skill"
    href="/docs/guides/create-skill"
  >
    Add reusable knowledge patterns
  </Card>
  <Card
    title="Create a Hook"
    href="/docs/guides/create-hook"
  >
    Add safety and observability
  </Card>
</Cards>
